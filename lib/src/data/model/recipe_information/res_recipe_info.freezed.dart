// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'res_recipe_info.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

ResRecipeInfo _$ResRecipeInfoFromJson(Map<String, dynamic> json) {
  return _ResRecipeInfo.fromJson(json);
}

/// @nodoc
mixin _$ResRecipeInfo {
  bool? get vegetarian => throw _privateConstructorUsedError;
  bool? get vegan => throw _privateConstructorUsedError;
  bool? get glutenFree => throw _privateConstructorUsedError;
  bool? get dairyFree => throw _privateConstructorUsedError;
  bool? get veryHealthy => throw _privateConstructorUsedError;
  bool? get cheap => throw _privateConstructorUsedError;
  bool? get veryPopular => throw _privateConstructorUsedError;
  bool? get sustainable => throw _privateConstructorUsedError;
  int? get weightWatcherSmartPoints => throw _privateConstructorUsedError;
  String? get gaps => throw _privateConstructorUsedError;
  bool? get lowFodmap => throw _privateConstructorUsedError;
  int? get aggregateLikes => throw _privateConstructorUsedError;
  double? get healthScore => throw _privateConstructorUsedError;
  String? get creditsText => throw _privateConstructorUsedError;
  String? get license => throw _privateConstructorUsedError;
  String? get sourceName => throw _privateConstructorUsedError;
  List<ExtendedIngredient>? get extendedIngredients =>
      throw _privateConstructorUsedError;
  int? get id => throw _privateConstructorUsedError;
  String? get title => throw _privateConstructorUsedError;
  int? get readyInMinutes => throw _privateConstructorUsedError;
  int? get servings => throw _privateConstructorUsedError;
  String? get sourceUrl => throw _privateConstructorUsedError;
  String? get image => throw _privateConstructorUsedError;
  String? get imageType => throw _privateConstructorUsedError;
  String? get summary => throw _privateConstructorUsedError;
  List<String>? get cuisines => throw _privateConstructorUsedError;
  List<String>? get dishTypes => throw _privateConstructorUsedError;
  List<String>? get diets => throw _privateConstructorUsedError;
  List<String>? get occasions => throw _privateConstructorUsedError;
  String? get instructions => throw _privateConstructorUsedError;
  List<AnalysedInstructions>? get analyzedInstructions =>
      throw _privateConstructorUsedError;
  dynamic get originalId => throw _privateConstructorUsedError;
  String? get spoonacularSourceUrl => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ResRecipeInfoCopyWith<ResRecipeInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ResRecipeInfoCopyWith<$Res> {
  factory $ResRecipeInfoCopyWith(
          ResRecipeInfo value, $Res Function(ResRecipeInfo) then) =
      _$ResRecipeInfoCopyWithImpl<$Res, ResRecipeInfo>;
  @useResult
  $Res call(
      {bool? vegetarian,
      bool? vegan,
      bool? glutenFree,
      bool? dairyFree,
      bool? veryHealthy,
      bool? cheap,
      bool? veryPopular,
      bool? sustainable,
      int? weightWatcherSmartPoints,
      String? gaps,
      bool? lowFodmap,
      int? aggregateLikes,
      double? healthScore,
      String? creditsText,
      String? license,
      String? sourceName,
      List<ExtendedIngredient>? extendedIngredients,
      int? id,
      String? title,
      int? readyInMinutes,
      int? servings,
      String? sourceUrl,
      String? image,
      String? imageType,
      String? summary,
      List<String>? cuisines,
      List<String>? dishTypes,
      List<String>? diets,
      List<String>? occasions,
      String? instructions,
      List<AnalysedInstructions>? analyzedInstructions,
      dynamic originalId,
      String? spoonacularSourceUrl});
}

/// @nodoc
class _$ResRecipeInfoCopyWithImpl<$Res, $Val extends ResRecipeInfo>
    implements $ResRecipeInfoCopyWith<$Res> {
  _$ResRecipeInfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vegetarian = freezed,
    Object? vegan = freezed,
    Object? glutenFree = freezed,
    Object? dairyFree = freezed,
    Object? veryHealthy = freezed,
    Object? cheap = freezed,
    Object? veryPopular = freezed,
    Object? sustainable = freezed,
    Object? weightWatcherSmartPoints = freezed,
    Object? gaps = freezed,
    Object? lowFodmap = freezed,
    Object? aggregateLikes = freezed,
    Object? healthScore = freezed,
    Object? creditsText = freezed,
    Object? license = freezed,
    Object? sourceName = freezed,
    Object? extendedIngredients = freezed,
    Object? id = freezed,
    Object? title = freezed,
    Object? readyInMinutes = freezed,
    Object? servings = freezed,
    Object? sourceUrl = freezed,
    Object? image = freezed,
    Object? imageType = freezed,
    Object? summary = freezed,
    Object? cuisines = freezed,
    Object? dishTypes = freezed,
    Object? diets = freezed,
    Object? occasions = freezed,
    Object? instructions = freezed,
    Object? analyzedInstructions = freezed,
    Object? originalId = freezed,
    Object? spoonacularSourceUrl = freezed,
  }) {
    return _then(_value.copyWith(
      vegetarian: freezed == vegetarian
          ? _value.vegetarian
          : vegetarian // ignore: cast_nullable_to_non_nullable
              as bool?,
      vegan: freezed == vegan
          ? _value.vegan
          : vegan // ignore: cast_nullable_to_non_nullable
              as bool?,
      glutenFree: freezed == glutenFree
          ? _value.glutenFree
          : glutenFree // ignore: cast_nullable_to_non_nullable
              as bool?,
      dairyFree: freezed == dairyFree
          ? _value.dairyFree
          : dairyFree // ignore: cast_nullable_to_non_nullable
              as bool?,
      veryHealthy: freezed == veryHealthy
          ? _value.veryHealthy
          : veryHealthy // ignore: cast_nullable_to_non_nullable
              as bool?,
      cheap: freezed == cheap
          ? _value.cheap
          : cheap // ignore: cast_nullable_to_non_nullable
              as bool?,
      veryPopular: freezed == veryPopular
          ? _value.veryPopular
          : veryPopular // ignore: cast_nullable_to_non_nullable
              as bool?,
      sustainable: freezed == sustainable
          ? _value.sustainable
          : sustainable // ignore: cast_nullable_to_non_nullable
              as bool?,
      weightWatcherSmartPoints: freezed == weightWatcherSmartPoints
          ? _value.weightWatcherSmartPoints
          : weightWatcherSmartPoints // ignore: cast_nullable_to_non_nullable
              as int?,
      gaps: freezed == gaps
          ? _value.gaps
          : gaps // ignore: cast_nullable_to_non_nullable
              as String?,
      lowFodmap: freezed == lowFodmap
          ? _value.lowFodmap
          : lowFodmap // ignore: cast_nullable_to_non_nullable
              as bool?,
      aggregateLikes: freezed == aggregateLikes
          ? _value.aggregateLikes
          : aggregateLikes // ignore: cast_nullable_to_non_nullable
              as int?,
      healthScore: freezed == healthScore
          ? _value.healthScore
          : healthScore // ignore: cast_nullable_to_non_nullable
              as double?,
      creditsText: freezed == creditsText
          ? _value.creditsText
          : creditsText // ignore: cast_nullable_to_non_nullable
              as String?,
      license: freezed == license
          ? _value.license
          : license // ignore: cast_nullable_to_non_nullable
              as String?,
      sourceName: freezed == sourceName
          ? _value.sourceName
          : sourceName // ignore: cast_nullable_to_non_nullable
              as String?,
      extendedIngredients: freezed == extendedIngredients
          ? _value.extendedIngredients
          : extendedIngredients // ignore: cast_nullable_to_non_nullable
              as List<ExtendedIngredient>?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      readyInMinutes: freezed == readyInMinutes
          ? _value.readyInMinutes
          : readyInMinutes // ignore: cast_nullable_to_non_nullable
              as int?,
      servings: freezed == servings
          ? _value.servings
          : servings // ignore: cast_nullable_to_non_nullable
              as int?,
      sourceUrl: freezed == sourceUrl
          ? _value.sourceUrl
          : sourceUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
      imageType: freezed == imageType
          ? _value.imageType
          : imageType // ignore: cast_nullable_to_non_nullable
              as String?,
      summary: freezed == summary
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as String?,
      cuisines: freezed == cuisines
          ? _value.cuisines
          : cuisines // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      dishTypes: freezed == dishTypes
          ? _value.dishTypes
          : dishTypes // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      diets: freezed == diets
          ? _value.diets
          : diets // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      occasions: freezed == occasions
          ? _value.occasions
          : occasions // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      analyzedInstructions: freezed == analyzedInstructions
          ? _value.analyzedInstructions
          : analyzedInstructions // ignore: cast_nullable_to_non_nullable
              as List<AnalysedInstructions>?,
      originalId: freezed == originalId
          ? _value.originalId
          : originalId // ignore: cast_nullable_to_non_nullable
              as dynamic,
      spoonacularSourceUrl: freezed == spoonacularSourceUrl
          ? _value.spoonacularSourceUrl
          : spoonacularSourceUrl // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ResRecipeInfoImplCopyWith<$Res>
    implements $ResRecipeInfoCopyWith<$Res> {
  factory _$$ResRecipeInfoImplCopyWith(
          _$ResRecipeInfoImpl value, $Res Function(_$ResRecipeInfoImpl) then) =
      __$$ResRecipeInfoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool? vegetarian,
      bool? vegan,
      bool? glutenFree,
      bool? dairyFree,
      bool? veryHealthy,
      bool? cheap,
      bool? veryPopular,
      bool? sustainable,
      int? weightWatcherSmartPoints,
      String? gaps,
      bool? lowFodmap,
      int? aggregateLikes,
      double? healthScore,
      String? creditsText,
      String? license,
      String? sourceName,
      List<ExtendedIngredient>? extendedIngredients,
      int? id,
      String? title,
      int? readyInMinutes,
      int? servings,
      String? sourceUrl,
      String? image,
      String? imageType,
      String? summary,
      List<String>? cuisines,
      List<String>? dishTypes,
      List<String>? diets,
      List<String>? occasions,
      String? instructions,
      List<AnalysedInstructions>? analyzedInstructions,
      dynamic originalId,
      String? spoonacularSourceUrl});
}

/// @nodoc
class __$$ResRecipeInfoImplCopyWithImpl<$Res>
    extends _$ResRecipeInfoCopyWithImpl<$Res, _$ResRecipeInfoImpl>
    implements _$$ResRecipeInfoImplCopyWith<$Res> {
  __$$ResRecipeInfoImplCopyWithImpl(
      _$ResRecipeInfoImpl _value, $Res Function(_$ResRecipeInfoImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vegetarian = freezed,
    Object? vegan = freezed,
    Object? glutenFree = freezed,
    Object? dairyFree = freezed,
    Object? veryHealthy = freezed,
    Object? cheap = freezed,
    Object? veryPopular = freezed,
    Object? sustainable = freezed,
    Object? weightWatcherSmartPoints = freezed,
    Object? gaps = freezed,
    Object? lowFodmap = freezed,
    Object? aggregateLikes = freezed,
    Object? healthScore = freezed,
    Object? creditsText = freezed,
    Object? license = freezed,
    Object? sourceName = freezed,
    Object? extendedIngredients = freezed,
    Object? id = freezed,
    Object? title = freezed,
    Object? readyInMinutes = freezed,
    Object? servings = freezed,
    Object? sourceUrl = freezed,
    Object? image = freezed,
    Object? imageType = freezed,
    Object? summary = freezed,
    Object? cuisines = freezed,
    Object? dishTypes = freezed,
    Object? diets = freezed,
    Object? occasions = freezed,
    Object? instructions = freezed,
    Object? analyzedInstructions = freezed,
    Object? originalId = freezed,
    Object? spoonacularSourceUrl = freezed,
  }) {
    return _then(_$ResRecipeInfoImpl(
      vegetarian: freezed == vegetarian
          ? _value.vegetarian
          : vegetarian // ignore: cast_nullable_to_non_nullable
              as bool?,
      vegan: freezed == vegan
          ? _value.vegan
          : vegan // ignore: cast_nullable_to_non_nullable
              as bool?,
      glutenFree: freezed == glutenFree
          ? _value.glutenFree
          : glutenFree // ignore: cast_nullable_to_non_nullable
              as bool?,
      dairyFree: freezed == dairyFree
          ? _value.dairyFree
          : dairyFree // ignore: cast_nullable_to_non_nullable
              as bool?,
      veryHealthy: freezed == veryHealthy
          ? _value.veryHealthy
          : veryHealthy // ignore: cast_nullable_to_non_nullable
              as bool?,
      cheap: freezed == cheap
          ? _value.cheap
          : cheap // ignore: cast_nullable_to_non_nullable
              as bool?,
      veryPopular: freezed == veryPopular
          ? _value.veryPopular
          : veryPopular // ignore: cast_nullable_to_non_nullable
              as bool?,
      sustainable: freezed == sustainable
          ? _value.sustainable
          : sustainable // ignore: cast_nullable_to_non_nullable
              as bool?,
      weightWatcherSmartPoints: freezed == weightWatcherSmartPoints
          ? _value.weightWatcherSmartPoints
          : weightWatcherSmartPoints // ignore: cast_nullable_to_non_nullable
              as int?,
      gaps: freezed == gaps
          ? _value.gaps
          : gaps // ignore: cast_nullable_to_non_nullable
              as String?,
      lowFodmap: freezed == lowFodmap
          ? _value.lowFodmap
          : lowFodmap // ignore: cast_nullable_to_non_nullable
              as bool?,
      aggregateLikes: freezed == aggregateLikes
          ? _value.aggregateLikes
          : aggregateLikes // ignore: cast_nullable_to_non_nullable
              as int?,
      healthScore: freezed == healthScore
          ? _value.healthScore
          : healthScore // ignore: cast_nullable_to_non_nullable
              as double?,
      creditsText: freezed == creditsText
          ? _value.creditsText
          : creditsText // ignore: cast_nullable_to_non_nullable
              as String?,
      license: freezed == license
          ? _value.license
          : license // ignore: cast_nullable_to_non_nullable
              as String?,
      sourceName: freezed == sourceName
          ? _value.sourceName
          : sourceName // ignore: cast_nullable_to_non_nullable
              as String?,
      extendedIngredients: freezed == extendedIngredients
          ? _value._extendedIngredients
          : extendedIngredients // ignore: cast_nullable_to_non_nullable
              as List<ExtendedIngredient>?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      readyInMinutes: freezed == readyInMinutes
          ? _value.readyInMinutes
          : readyInMinutes // ignore: cast_nullable_to_non_nullable
              as int?,
      servings: freezed == servings
          ? _value.servings
          : servings // ignore: cast_nullable_to_non_nullable
              as int?,
      sourceUrl: freezed == sourceUrl
          ? _value.sourceUrl
          : sourceUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
      imageType: freezed == imageType
          ? _value.imageType
          : imageType // ignore: cast_nullable_to_non_nullable
              as String?,
      summary: freezed == summary
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as String?,
      cuisines: freezed == cuisines
          ? _value._cuisines
          : cuisines // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      dishTypes: freezed == dishTypes
          ? _value._dishTypes
          : dishTypes // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      diets: freezed == diets
          ? _value._diets
          : diets // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      occasions: freezed == occasions
          ? _value._occasions
          : occasions // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      analyzedInstructions: freezed == analyzedInstructions
          ? _value._analyzedInstructions
          : analyzedInstructions // ignore: cast_nullable_to_non_nullable
              as List<AnalysedInstructions>?,
      originalId: freezed == originalId
          ? _value.originalId
          : originalId // ignore: cast_nullable_to_non_nullable
              as dynamic,
      spoonacularSourceUrl: freezed == spoonacularSourceUrl
          ? _value.spoonacularSourceUrl
          : spoonacularSourceUrl // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ResRecipeInfoImpl implements _ResRecipeInfo {
  const _$ResRecipeInfoImpl(
      {this.vegetarian,
      this.vegan,
      this.glutenFree,
      this.dairyFree,
      this.veryHealthy,
      this.cheap,
      this.veryPopular,
      this.sustainable,
      this.weightWatcherSmartPoints,
      this.gaps,
      this.lowFodmap,
      this.aggregateLikes,
      this.healthScore,
      this.creditsText,
      this.license,
      this.sourceName,
      final List<ExtendedIngredient>? extendedIngredients,
      this.id,
      this.title,
      this.readyInMinutes,
      this.servings,
      this.sourceUrl,
      this.image,
      this.imageType,
      this.summary,
      final List<String>? cuisines,
      final List<String>? dishTypes,
      final List<String>? diets,
      final List<String>? occasions,
      this.instructions,
      final List<AnalysedInstructions>? analyzedInstructions,
      this.originalId,
      this.spoonacularSourceUrl})
      : _extendedIngredients = extendedIngredients,
        _cuisines = cuisines,
        _dishTypes = dishTypes,
        _diets = diets,
        _occasions = occasions,
        _analyzedInstructions = analyzedInstructions;

  factory _$ResRecipeInfoImpl.fromJson(Map<String, dynamic> json) =>
      _$$ResRecipeInfoImplFromJson(json);

  @override
  final bool? vegetarian;
  @override
  final bool? vegan;
  @override
  final bool? glutenFree;
  @override
  final bool? dairyFree;
  @override
  final bool? veryHealthy;
  @override
  final bool? cheap;
  @override
  final bool? veryPopular;
  @override
  final bool? sustainable;
  @override
  final int? weightWatcherSmartPoints;
  @override
  final String? gaps;
  @override
  final bool? lowFodmap;
  @override
  final int? aggregateLikes;
  @override
  final double? healthScore;
  @override
  final String? creditsText;
  @override
  final String? license;
  @override
  final String? sourceName;
  final List<ExtendedIngredient>? _extendedIngredients;
  @override
  List<ExtendedIngredient>? get extendedIngredients {
    final value = _extendedIngredients;
    if (value == null) return null;
    if (_extendedIngredients is EqualUnmodifiableListView)
      return _extendedIngredients;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final int? id;
  @override
  final String? title;
  @override
  final int? readyInMinutes;
  @override
  final int? servings;
  @override
  final String? sourceUrl;
  @override
  final String? image;
  @override
  final String? imageType;
  @override
  final String? summary;
  final List<String>? _cuisines;
  @override
  List<String>? get cuisines {
    final value = _cuisines;
    if (value == null) return null;
    if (_cuisines is EqualUnmodifiableListView) return _cuisines;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _dishTypes;
  @override
  List<String>? get dishTypes {
    final value = _dishTypes;
    if (value == null) return null;
    if (_dishTypes is EqualUnmodifiableListView) return _dishTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _diets;
  @override
  List<String>? get diets {
    final value = _diets;
    if (value == null) return null;
    if (_diets is EqualUnmodifiableListView) return _diets;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _occasions;
  @override
  List<String>? get occasions {
    final value = _occasions;
    if (value == null) return null;
    if (_occasions is EqualUnmodifiableListView) return _occasions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String? instructions;
  final List<AnalysedInstructions>? _analyzedInstructions;
  @override
  List<AnalysedInstructions>? get analyzedInstructions {
    final value = _analyzedInstructions;
    if (value == null) return null;
    if (_analyzedInstructions is EqualUnmodifiableListView)
      return _analyzedInstructions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final dynamic originalId;
  @override
  final String? spoonacularSourceUrl;

  @override
  String toString() {
    return 'ResRecipeInfo(vegetarian: $vegetarian, vegan: $vegan, glutenFree: $glutenFree, dairyFree: $dairyFree, veryHealthy: $veryHealthy, cheap: $cheap, veryPopular: $veryPopular, sustainable: $sustainable, weightWatcherSmartPoints: $weightWatcherSmartPoints, gaps: $gaps, lowFodmap: $lowFodmap, aggregateLikes: $aggregateLikes, healthScore: $healthScore, creditsText: $creditsText, license: $license, sourceName: $sourceName, extendedIngredients: $extendedIngredients, id: $id, title: $title, readyInMinutes: $readyInMinutes, servings: $servings, sourceUrl: $sourceUrl, image: $image, imageType: $imageType, summary: $summary, cuisines: $cuisines, dishTypes: $dishTypes, diets: $diets, occasions: $occasions, instructions: $instructions, analyzedInstructions: $analyzedInstructions, originalId: $originalId, spoonacularSourceUrl: $spoonacularSourceUrl)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ResRecipeInfoImpl &&
            (identical(other.vegetarian, vegetarian) ||
                other.vegetarian == vegetarian) &&
            (identical(other.vegan, vegan) || other.vegan == vegan) &&
            (identical(other.glutenFree, glutenFree) ||
                other.glutenFree == glutenFree) &&
            (identical(other.dairyFree, dairyFree) ||
                other.dairyFree == dairyFree) &&
            (identical(other.veryHealthy, veryHealthy) ||
                other.veryHealthy == veryHealthy) &&
            (identical(other.cheap, cheap) || other.cheap == cheap) &&
            (identical(other.veryPopular, veryPopular) ||
                other.veryPopular == veryPopular) &&
            (identical(other.sustainable, sustainable) ||
                other.sustainable == sustainable) &&
            (identical(
                    other.weightWatcherSmartPoints, weightWatcherSmartPoints) ||
                other.weightWatcherSmartPoints == weightWatcherSmartPoints) &&
            (identical(other.gaps, gaps) || other.gaps == gaps) &&
            (identical(other.lowFodmap, lowFodmap) ||
                other.lowFodmap == lowFodmap) &&
            (identical(other.aggregateLikes, aggregateLikes) ||
                other.aggregateLikes == aggregateLikes) &&
            (identical(other.healthScore, healthScore) ||
                other.healthScore == healthScore) &&
            (identical(other.creditsText, creditsText) ||
                other.creditsText == creditsText) &&
            (identical(other.license, license) || other.license == license) &&
            (identical(other.sourceName, sourceName) ||
                other.sourceName == sourceName) &&
            const DeepCollectionEquality()
                .equals(other._extendedIngredients, _extendedIngredients) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.readyInMinutes, readyInMinutes) ||
                other.readyInMinutes == readyInMinutes) &&
            (identical(other.servings, servings) ||
                other.servings == servings) &&
            (identical(other.sourceUrl, sourceUrl) ||
                other.sourceUrl == sourceUrl) &&
            (identical(other.image, image) || other.image == image) &&
            (identical(other.imageType, imageType) ||
                other.imageType == imageType) &&
            (identical(other.summary, summary) || other.summary == summary) &&
            const DeepCollectionEquality().equals(other._cuisines, _cuisines) &&
            const DeepCollectionEquality()
                .equals(other._dishTypes, _dishTypes) &&
            const DeepCollectionEquality().equals(other._diets, _diets) &&
            const DeepCollectionEquality()
                .equals(other._occasions, _occasions) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality()
                .equals(other._analyzedInstructions, _analyzedInstructions) &&
            const DeepCollectionEquality()
                .equals(other.originalId, originalId) &&
            (identical(other.spoonacularSourceUrl, spoonacularSourceUrl) ||
                other.spoonacularSourceUrl == spoonacularSourceUrl));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        vegetarian,
        vegan,
        glutenFree,
        dairyFree,
        veryHealthy,
        cheap,
        veryPopular,
        sustainable,
        weightWatcherSmartPoints,
        gaps,
        lowFodmap,
        aggregateLikes,
        healthScore,
        creditsText,
        license,
        sourceName,
        const DeepCollectionEquality().hash(_extendedIngredients),
        id,
        title,
        readyInMinutes,
        servings,
        sourceUrl,
        image,
        imageType,
        summary,
        const DeepCollectionEquality().hash(_cuisines),
        const DeepCollectionEquality().hash(_dishTypes),
        const DeepCollectionEquality().hash(_diets),
        const DeepCollectionEquality().hash(_occasions),
        instructions,
        const DeepCollectionEquality().hash(_analyzedInstructions),
        const DeepCollectionEquality().hash(originalId),
        spoonacularSourceUrl
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ResRecipeInfoImplCopyWith<_$ResRecipeInfoImpl> get copyWith =>
      __$$ResRecipeInfoImplCopyWithImpl<_$ResRecipeInfoImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ResRecipeInfoImplToJson(
      this,
    );
  }
}

abstract class _ResRecipeInfo implements ResRecipeInfo {
  const factory _ResRecipeInfo(
      {final bool? vegetarian,
      final bool? vegan,
      final bool? glutenFree,
      final bool? dairyFree,
      final bool? veryHealthy,
      final bool? cheap,
      final bool? veryPopular,
      final bool? sustainable,
      final int? weightWatcherSmartPoints,
      final String? gaps,
      final bool? lowFodmap,
      final int? aggregateLikes,
      final double? healthScore,
      final String? creditsText,
      final String? license,
      final String? sourceName,
      final List<ExtendedIngredient>? extendedIngredients,
      final int? id,
      final String? title,
      final int? readyInMinutes,
      final int? servings,
      final String? sourceUrl,
      final String? image,
      final String? imageType,
      final String? summary,
      final List<String>? cuisines,
      final List<String>? dishTypes,
      final List<String>? diets,
      final List<String>? occasions,
      final String? instructions,
      final List<AnalysedInstructions>? analyzedInstructions,
      final dynamic originalId,
      final String? spoonacularSourceUrl}) = _$ResRecipeInfoImpl;

  factory _ResRecipeInfo.fromJson(Map<String, dynamic> json) =
      _$ResRecipeInfoImpl.fromJson;

  @override
  bool? get vegetarian;
  @override
  bool? get vegan;
  @override
  bool? get glutenFree;
  @override
  bool? get dairyFree;
  @override
  bool? get veryHealthy;
  @override
  bool? get cheap;
  @override
  bool? get veryPopular;
  @override
  bool? get sustainable;
  @override
  int? get weightWatcherSmartPoints;
  @override
  String? get gaps;
  @override
  bool? get lowFodmap;
  @override
  int? get aggregateLikes;
  @override
  double? get healthScore;
  @override
  String? get creditsText;
  @override
  String? get license;
  @override
  String? get sourceName;
  @override
  List<ExtendedIngredient>? get extendedIngredients;
  @override
  int? get id;
  @override
  String? get title;
  @override
  int? get readyInMinutes;
  @override
  int? get servings;
  @override
  String? get sourceUrl;
  @override
  String? get image;
  @override
  String? get imageType;
  @override
  String? get summary;
  @override
  List<String>? get cuisines;
  @override
  List<String>? get dishTypes;
  @override
  List<String>? get diets;
  @override
  List<String>? get occasions;
  @override
  String? get instructions;
  @override
  List<AnalysedInstructions>? get analyzedInstructions;
  @override
  dynamic get originalId;
  @override
  String? get spoonacularSourceUrl;
  @override
  @JsonKey(ignore: true)
  _$$ResRecipeInfoImplCopyWith<_$ResRecipeInfoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ExtendedIngredient _$ExtendedIngredientFromJson(Map<String, dynamic> json) {
  return _ExtendedIngredient.fromJson(json);
}

/// @nodoc
mixin _$ExtendedIngredient {
  int? get id => throw _privateConstructorUsedError;
  String? get aisle => throw _privateConstructorUsedError;
  String? get image => throw _privateConstructorUsedError;
  String? get consistency => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;
  String? get nameClean => throw _privateConstructorUsedError;
  String? get original => throw _privateConstructorUsedError;
  String? get originalString => throw _privateConstructorUsedError;
  String? get originalName => throw _privateConstructorUsedError;
  double? get amount => throw _privateConstructorUsedError;
  String? get unit => throw _privateConstructorUsedError;
  List<String>? get meta => throw _privateConstructorUsedError;
  List<String>? get metaInformation => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExtendedIngredientCopyWith<ExtendedIngredient> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExtendedIngredientCopyWith<$Res> {
  factory $ExtendedIngredientCopyWith(
          ExtendedIngredient value, $Res Function(ExtendedIngredient) then) =
      _$ExtendedIngredientCopyWithImpl<$Res, ExtendedIngredient>;
  @useResult
  $Res call(
      {int? id,
      String? aisle,
      String? image,
      String? consistency,
      String? name,
      String? nameClean,
      String? original,
      String? originalString,
      String? originalName,
      double? amount,
      String? unit,
      List<String>? meta,
      List<String>? metaInformation});
}

/// @nodoc
class _$ExtendedIngredientCopyWithImpl<$Res, $Val extends ExtendedIngredient>
    implements $ExtendedIngredientCopyWith<$Res> {
  _$ExtendedIngredientCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? aisle = freezed,
    Object? image = freezed,
    Object? consistency = freezed,
    Object? name = freezed,
    Object? nameClean = freezed,
    Object? original = freezed,
    Object? originalString = freezed,
    Object? originalName = freezed,
    Object? amount = freezed,
    Object? unit = freezed,
    Object? meta = freezed,
    Object? metaInformation = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      aisle: freezed == aisle
          ? _value.aisle
          : aisle // ignore: cast_nullable_to_non_nullable
              as String?,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
      consistency: freezed == consistency
          ? _value.consistency
          : consistency // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameClean: freezed == nameClean
          ? _value.nameClean
          : nameClean // ignore: cast_nullable_to_non_nullable
              as String?,
      original: freezed == original
          ? _value.original
          : original // ignore: cast_nullable_to_non_nullable
              as String?,
      originalString: freezed == originalString
          ? _value.originalString
          : originalString // ignore: cast_nullable_to_non_nullable
              as String?,
      originalName: freezed == originalName
          ? _value.originalName
          : originalName // ignore: cast_nullable_to_non_nullable
              as String?,
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as double?,
      unit: freezed == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      metaInformation: freezed == metaInformation
          ? _value.metaInformation
          : metaInformation // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ExtendedIngredientImplCopyWith<$Res>
    implements $ExtendedIngredientCopyWith<$Res> {
  factory _$$ExtendedIngredientImplCopyWith(_$ExtendedIngredientImpl value,
          $Res Function(_$ExtendedIngredientImpl) then) =
      __$$ExtendedIngredientImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int? id,
      String? aisle,
      String? image,
      String? consistency,
      String? name,
      String? nameClean,
      String? original,
      String? originalString,
      String? originalName,
      double? amount,
      String? unit,
      List<String>? meta,
      List<String>? metaInformation});
}

/// @nodoc
class __$$ExtendedIngredientImplCopyWithImpl<$Res>
    extends _$ExtendedIngredientCopyWithImpl<$Res, _$ExtendedIngredientImpl>
    implements _$$ExtendedIngredientImplCopyWith<$Res> {
  __$$ExtendedIngredientImplCopyWithImpl(_$ExtendedIngredientImpl _value,
      $Res Function(_$ExtendedIngredientImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? aisle = freezed,
    Object? image = freezed,
    Object? consistency = freezed,
    Object? name = freezed,
    Object? nameClean = freezed,
    Object? original = freezed,
    Object? originalString = freezed,
    Object? originalName = freezed,
    Object? amount = freezed,
    Object? unit = freezed,
    Object? meta = freezed,
    Object? metaInformation = freezed,
  }) {
    return _then(_$ExtendedIngredientImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      aisle: freezed == aisle
          ? _value.aisle
          : aisle // ignore: cast_nullable_to_non_nullable
              as String?,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
      consistency: freezed == consistency
          ? _value.consistency
          : consistency // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameClean: freezed == nameClean
          ? _value.nameClean
          : nameClean // ignore: cast_nullable_to_non_nullable
              as String?,
      original: freezed == original
          ? _value.original
          : original // ignore: cast_nullable_to_non_nullable
              as String?,
      originalString: freezed == originalString
          ? _value.originalString
          : originalString // ignore: cast_nullable_to_non_nullable
              as String?,
      originalName: freezed == originalName
          ? _value.originalName
          : originalName // ignore: cast_nullable_to_non_nullable
              as String?,
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as double?,
      unit: freezed == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value._meta
          : meta // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      metaInformation: freezed == metaInformation
          ? _value._metaInformation
          : metaInformation // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExtendedIngredientImpl implements _ExtendedIngredient {
  const _$ExtendedIngredientImpl(
      {this.id,
      this.aisle,
      this.image,
      this.consistency,
      this.name,
      this.nameClean,
      this.original,
      this.originalString,
      this.originalName,
      this.amount,
      this.unit,
      required final List<String>? meta,
      required final List<String>? metaInformation})
      : _meta = meta,
        _metaInformation = metaInformation;

  factory _$ExtendedIngredientImpl.fromJson(Map<String, dynamic> json) =>
      _$$ExtendedIngredientImplFromJson(json);

  @override
  final int? id;
  @override
  final String? aisle;
  @override
  final String? image;
  @override
  final String? consistency;
  @override
  final String? name;
  @override
  final String? nameClean;
  @override
  final String? original;
  @override
  final String? originalString;
  @override
  final String? originalName;
  @override
  final double? amount;
  @override
  final String? unit;
  final List<String>? _meta;
  @override
  List<String>? get meta {
    final value = _meta;
    if (value == null) return null;
    if (_meta is EqualUnmodifiableListView) return _meta;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _metaInformation;
  @override
  List<String>? get metaInformation {
    final value = _metaInformation;
    if (value == null) return null;
    if (_metaInformation is EqualUnmodifiableListView) return _metaInformation;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ExtendedIngredient(id: $id, aisle: $aisle, image: $image, consistency: $consistency, name: $name, nameClean: $nameClean, original: $original, originalString: $originalString, originalName: $originalName, amount: $amount, unit: $unit, meta: $meta, metaInformation: $metaInformation)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExtendedIngredientImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.aisle, aisle) || other.aisle == aisle) &&
            (identical(other.image, image) || other.image == image) &&
            (identical(other.consistency, consistency) ||
                other.consistency == consistency) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.nameClean, nameClean) ||
                other.nameClean == nameClean) &&
            (identical(other.original, original) ||
                other.original == original) &&
            (identical(other.originalString, originalString) ||
                other.originalString == originalString) &&
            (identical(other.originalName, originalName) ||
                other.originalName == originalName) &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.unit, unit) || other.unit == unit) &&
            const DeepCollectionEquality().equals(other._meta, _meta) &&
            const DeepCollectionEquality()
                .equals(other._metaInformation, _metaInformation));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      aisle,
      image,
      consistency,
      name,
      nameClean,
      original,
      originalString,
      originalName,
      amount,
      unit,
      const DeepCollectionEquality().hash(_meta),
      const DeepCollectionEquality().hash(_metaInformation));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExtendedIngredientImplCopyWith<_$ExtendedIngredientImpl> get copyWith =>
      __$$ExtendedIngredientImplCopyWithImpl<_$ExtendedIngredientImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExtendedIngredientImplToJson(
      this,
    );
  }
}

abstract class _ExtendedIngredient implements ExtendedIngredient {
  const factory _ExtendedIngredient(
      {final int? id,
      final String? aisle,
      final String? image,
      final String? consistency,
      final String? name,
      final String? nameClean,
      final String? original,
      final String? originalString,
      final String? originalName,
      final double? amount,
      final String? unit,
      required final List<String>? meta,
      required final List<String>? metaInformation}) = _$ExtendedIngredientImpl;

  factory _ExtendedIngredient.fromJson(Map<String, dynamic> json) =
      _$ExtendedIngredientImpl.fromJson;

  @override
  int? get id;
  @override
  String? get aisle;
  @override
  String? get image;
  @override
  String? get consistency;
  @override
  String? get name;
  @override
  String? get nameClean;
  @override
  String? get original;
  @override
  String? get originalString;
  @override
  String? get originalName;
  @override
  double? get amount;
  @override
  String? get unit;
  @override
  List<String>? get meta;
  @override
  List<String>? get metaInformation;
  @override
  @JsonKey(ignore: true)
  _$$ExtendedIngredientImplCopyWith<_$ExtendedIngredientImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AnalysedInstructions _$AnalysedInstructionsFromJson(Map<String, dynamic> json) {
  return _AnalysedInstructions.fromJson(json);
}

/// @nodoc
mixin _$AnalysedInstructions {
  String? get name => throw _privateConstructorUsedError;
  List<Step>? get steps => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AnalysedInstructionsCopyWith<AnalysedInstructions> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnalysedInstructionsCopyWith<$Res> {
  factory $AnalysedInstructionsCopyWith(AnalysedInstructions value,
          $Res Function(AnalysedInstructions) then) =
      _$AnalysedInstructionsCopyWithImpl<$Res, AnalysedInstructions>;
  @useResult
  $Res call({String? name, List<Step>? steps});
}

/// @nodoc
class _$AnalysedInstructionsCopyWithImpl<$Res,
        $Val extends AnalysedInstructions>
    implements $AnalysedInstructionsCopyWith<$Res> {
  _$AnalysedInstructionsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? steps = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      steps: freezed == steps
          ? _value.steps
          : steps // ignore: cast_nullable_to_non_nullable
              as List<Step>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AnalysedInstructionsImplCopyWith<$Res>
    implements $AnalysedInstructionsCopyWith<$Res> {
  factory _$$AnalysedInstructionsImplCopyWith(_$AnalysedInstructionsImpl value,
          $Res Function(_$AnalysedInstructionsImpl) then) =
      __$$AnalysedInstructionsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? name, List<Step>? steps});
}

/// @nodoc
class __$$AnalysedInstructionsImplCopyWithImpl<$Res>
    extends _$AnalysedInstructionsCopyWithImpl<$Res, _$AnalysedInstructionsImpl>
    implements _$$AnalysedInstructionsImplCopyWith<$Res> {
  __$$AnalysedInstructionsImplCopyWithImpl(_$AnalysedInstructionsImpl _value,
      $Res Function(_$AnalysedInstructionsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? steps = freezed,
  }) {
    return _then(_$AnalysedInstructionsImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      steps: freezed == steps
          ? _value._steps
          : steps // ignore: cast_nullable_to_non_nullable
              as List<Step>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AnalysedInstructionsImpl implements _AnalysedInstructions {
  const _$AnalysedInstructionsImpl(
      {this.name, required final List<Step>? steps})
      : _steps = steps;

  factory _$AnalysedInstructionsImpl.fromJson(Map<String, dynamic> json) =>
      _$$AnalysedInstructionsImplFromJson(json);

  @override
  final String? name;
  final List<Step>? _steps;
  @override
  List<Step>? get steps {
    final value = _steps;
    if (value == null) return null;
    if (_steps is EqualUnmodifiableListView) return _steps;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'AnalysedInstructions(name: $name, steps: $steps)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedInstructionsImpl &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other._steps, _steps));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, name, const DeepCollectionEquality().hash(_steps));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedInstructionsImplCopyWith<_$AnalysedInstructionsImpl>
      get copyWith =>
          __$$AnalysedInstructionsImplCopyWithImpl<_$AnalysedInstructionsImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AnalysedInstructionsImplToJson(
      this,
    );
  }
}

abstract class _AnalysedInstructions implements AnalysedInstructions {
  const factory _AnalysedInstructions(
      {final String? name,
      required final List<Step>? steps}) = _$AnalysedInstructionsImpl;

  factory _AnalysedInstructions.fromJson(Map<String, dynamic> json) =
      _$AnalysedInstructionsImpl.fromJson;

  @override
  String? get name;
  @override
  List<Step>? get steps;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedInstructionsImplCopyWith<_$AnalysedInstructionsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

Step _$StepFromJson(Map<String, dynamic> json) {
  return _Step.fromJson(json);
}

/// @nodoc
mixin _$Step {
  int? get number => throw _privateConstructorUsedError;
  String? get step => throw _privateConstructorUsedError;
  List<Ent>? get ingredients => throw _privateConstructorUsedError;
  List<Ent>? get equipment => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $StepCopyWith<Step> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StepCopyWith<$Res> {
  factory $StepCopyWith(Step value, $Res Function(Step) then) =
      _$StepCopyWithImpl<$Res, Step>;
  @useResult
  $Res call(
      {int? number,
      String? step,
      List<Ent>? ingredients,
      List<Ent>? equipment});
}

/// @nodoc
class _$StepCopyWithImpl<$Res, $Val extends Step>
    implements $StepCopyWith<$Res> {
  _$StepCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? number = freezed,
    Object? step = freezed,
    Object? ingredients = freezed,
    Object? equipment = freezed,
  }) {
    return _then(_value.copyWith(
      number: freezed == number
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as int?,
      step: freezed == step
          ? _value.step
          : step // ignore: cast_nullable_to_non_nullable
              as String?,
      ingredients: freezed == ingredients
          ? _value.ingredients
          : ingredients // ignore: cast_nullable_to_non_nullable
              as List<Ent>?,
      equipment: freezed == equipment
          ? _value.equipment
          : equipment // ignore: cast_nullable_to_non_nullable
              as List<Ent>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$StepImplCopyWith<$Res> implements $StepCopyWith<$Res> {
  factory _$$StepImplCopyWith(
          _$StepImpl value, $Res Function(_$StepImpl) then) =
      __$$StepImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int? number,
      String? step,
      List<Ent>? ingredients,
      List<Ent>? equipment});
}

/// @nodoc
class __$$StepImplCopyWithImpl<$Res>
    extends _$StepCopyWithImpl<$Res, _$StepImpl>
    implements _$$StepImplCopyWith<$Res> {
  __$$StepImplCopyWithImpl(_$StepImpl _value, $Res Function(_$StepImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? number = freezed,
    Object? step = freezed,
    Object? ingredients = freezed,
    Object? equipment = freezed,
  }) {
    return _then(_$StepImpl(
      number: freezed == number
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as int?,
      step: freezed == step
          ? _value.step
          : step // ignore: cast_nullable_to_non_nullable
              as String?,
      ingredients: freezed == ingredients
          ? _value._ingredients
          : ingredients // ignore: cast_nullable_to_non_nullable
              as List<Ent>?,
      equipment: freezed == equipment
          ? _value._equipment
          : equipment // ignore: cast_nullable_to_non_nullable
              as List<Ent>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$StepImpl implements _Step {
  const _$StepImpl(
      {this.number,
      this.step,
      required final List<Ent>? ingredients,
      required final List<Ent>? equipment})
      : _ingredients = ingredients,
        _equipment = equipment;

  factory _$StepImpl.fromJson(Map<String, dynamic> json) =>
      _$$StepImplFromJson(json);

  @override
  final int? number;
  @override
  final String? step;
  final List<Ent>? _ingredients;
  @override
  List<Ent>? get ingredients {
    final value = _ingredients;
    if (value == null) return null;
    if (_ingredients is EqualUnmodifiableListView) return _ingredients;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Ent>? _equipment;
  @override
  List<Ent>? get equipment {
    final value = _equipment;
    if (value == null) return null;
    if (_equipment is EqualUnmodifiableListView) return _equipment;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Step(number: $number, step: $step, ingredients: $ingredients, equipment: $equipment)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StepImpl &&
            (identical(other.number, number) || other.number == number) &&
            (identical(other.step, step) || other.step == step) &&
            const DeepCollectionEquality()
                .equals(other._ingredients, _ingredients) &&
            const DeepCollectionEquality()
                .equals(other._equipment, _equipment));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      number,
      step,
      const DeepCollectionEquality().hash(_ingredients),
      const DeepCollectionEquality().hash(_equipment));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StepImplCopyWith<_$StepImpl> get copyWith =>
      __$$StepImplCopyWithImpl<_$StepImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$StepImplToJson(
      this,
    );
  }
}

abstract class _Step implements Step {
  const factory _Step(
      {final int? number,
      final String? step,
      required final List<Ent>? ingredients,
      required final List<Ent>? equipment}) = _$StepImpl;

  factory _Step.fromJson(Map<String, dynamic> json) = _$StepImpl.fromJson;

  @override
  int? get number;
  @override
  String? get step;
  @override
  List<Ent>? get ingredients;
  @override
  List<Ent>? get equipment;
  @override
  @JsonKey(ignore: true)
  _$$StepImplCopyWith<_$StepImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Ent _$EntFromJson(Map<String, dynamic> json) {
  return _Ent.fromJson(json);
}

/// @nodoc
mixin _$Ent {
  int? get id => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;
  String? get localizedName => throw _privateConstructorUsedError;
  String? get image => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EntCopyWith<Ent> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EntCopyWith<$Res> {
  factory $EntCopyWith(Ent value, $Res Function(Ent) then) =
      _$EntCopyWithImpl<$Res, Ent>;
  @useResult
  $Res call({int? id, String? name, String? localizedName, String? image});
}

/// @nodoc
class _$EntCopyWithImpl<$Res, $Val extends Ent> implements $EntCopyWith<$Res> {
  _$EntCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? localizedName = freezed,
    Object? image = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      localizedName: freezed == localizedName
          ? _value.localizedName
          : localizedName // ignore: cast_nullable_to_non_nullable
              as String?,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EntImplCopyWith<$Res> implements $EntCopyWith<$Res> {
  factory _$$EntImplCopyWith(_$EntImpl value, $Res Function(_$EntImpl) then) =
      __$$EntImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? id, String? name, String? localizedName, String? image});
}

/// @nodoc
class __$$EntImplCopyWithImpl<$Res> extends _$EntCopyWithImpl<$Res, _$EntImpl>
    implements _$$EntImplCopyWith<$Res> {
  __$$EntImplCopyWithImpl(_$EntImpl _value, $Res Function(_$EntImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? localizedName = freezed,
    Object? image = freezed,
  }) {
    return _then(_$EntImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      localizedName: freezed == localizedName
          ? _value.localizedName
          : localizedName // ignore: cast_nullable_to_non_nullable
              as String?,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EntImpl implements _Ent {
  const _$EntImpl({this.id, this.name, this.localizedName, this.image});

  factory _$EntImpl.fromJson(Map<String, dynamic> json) =>
      _$$EntImplFromJson(json);

  @override
  final int? id;
  @override
  final String? name;
  @override
  final String? localizedName;
  @override
  final String? image;

  @override
  String toString() {
    return 'Ent(id: $id, name: $name, localizedName: $localizedName, image: $image)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EntImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.localizedName, localizedName) ||
                other.localizedName == localizedName) &&
            (identical(other.image, image) || other.image == image));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, localizedName, image);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EntImplCopyWith<_$EntImpl> get copyWith =>
      __$$EntImplCopyWithImpl<_$EntImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EntImplToJson(
      this,
    );
  }
}

abstract class _Ent implements Ent {
  const factory _Ent(
      {final int? id,
      final String? name,
      final String? localizedName,
      final String? image}) = _$EntImpl;

  factory _Ent.fromJson(Map<String, dynamic> json) = _$EntImpl.fromJson;

  @override
  int? get id;
  @override
  String? get name;
  @override
  String? get localizedName;
  @override
  String? get image;
  @override
  @JsonKey(ignore: true)
  _$$EntImplCopyWith<_$EntImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Length _$LengthFromJson(Map<String, dynamic> json) {
  return _Length.fromJson(json);
}

/// @nodoc
mixin _$Length {
  int? get number => throw _privateConstructorUsedError;
  String? get unit => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LengthCopyWith<Length> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LengthCopyWith<$Res> {
  factory $LengthCopyWith(Length value, $Res Function(Length) then) =
      _$LengthCopyWithImpl<$Res, Length>;
  @useResult
  $Res call({int? number, String? unit});
}

/// @nodoc
class _$LengthCopyWithImpl<$Res, $Val extends Length>
    implements $LengthCopyWith<$Res> {
  _$LengthCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? number = freezed,
    Object? unit = freezed,
  }) {
    return _then(_value.copyWith(
      number: freezed == number
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as int?,
      unit: freezed == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LengthImplCopyWith<$Res> implements $LengthCopyWith<$Res> {
  factory _$$LengthImplCopyWith(
          _$LengthImpl value, $Res Function(_$LengthImpl) then) =
      __$$LengthImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? number, String? unit});
}

/// @nodoc
class __$$LengthImplCopyWithImpl<$Res>
    extends _$LengthCopyWithImpl<$Res, _$LengthImpl>
    implements _$$LengthImplCopyWith<$Res> {
  __$$LengthImplCopyWithImpl(
      _$LengthImpl _value, $Res Function(_$LengthImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? number = freezed,
    Object? unit = freezed,
  }) {
    return _then(_$LengthImpl(
      number: freezed == number
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as int?,
      unit: freezed == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$LengthImpl implements _Length {
  const _$LengthImpl({this.number, this.unit});

  factory _$LengthImpl.fromJson(Map<String, dynamic> json) =>
      _$$LengthImplFromJson(json);

  @override
  final int? number;
  @override
  final String? unit;

  @override
  String toString() {
    return 'Length(number: $number, unit: $unit)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LengthImpl &&
            (identical(other.number, number) || other.number == number) &&
            (identical(other.unit, unit) || other.unit == unit));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, number, unit);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LengthImplCopyWith<_$LengthImpl> get copyWith =>
      __$$LengthImplCopyWithImpl<_$LengthImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LengthImplToJson(
      this,
    );
  }
}

abstract class _Length implements Length {
  const factory _Length({final int? number, final String? unit}) = _$LengthImpl;

  factory _Length.fromJson(Map<String, dynamic> json) = _$LengthImpl.fromJson;

  @override
  int? get number;
  @override
  String? get unit;
  @override
  @JsonKey(ignore: true)
  _$$LengthImplCopyWith<_$LengthImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
